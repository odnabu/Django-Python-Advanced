# \\\\\\\   ТЕСТИРОВАНИЕ    ///////////////////////////////////////////////////////////////////////////////////
# Link on GitHub: https://github.com/viacheslav-bandylo/111124-projects/blob/main/library/tests.py
#   1. Начало -->  VIDEO "Project 5: Консультация: финальный проект" 2:05:50.
#      url: https://player.vimeo.com/video/1106434843?h=9bf0582a7c
#   2. Продолжение -->  VIDEO "Project 6: Консультация: финальный проект" 54:00.
#      url: https://player.vimeo.com/video/1107052048?h=4bc883f8d0

# VIDEO P.5, 2:17:00.
# __TestCase__ - тестирование любой логики, НЕ связанной с API. Его главная особенность состоит в "оборочивании"
# каждой транзакции и после завершения теста - откатывании всей БД назад.
# При этом тесты не влияют друг на друга и на состояние БД.
from django.test import TestCase

# VIDEO P.5, 2:19:50.
# __APITestCase__ - класс для тестирования именно API, умеет все то же, что и TestCase.
# Но дополнительно предоставляет серьезные инструменты для работы с API:
#   - встроенные классы для отправки HTTP-запросов,
#   - удобная работа с JSON,
#   - помощь в аутентификации: проще залогиниваться/разлогиниваться.
from rest_framework.test import APITestCase

# ВЫВОД:
#   - если что-то тестируется внутри Django (методы моделей, бизнес-логика) - можно использовать TestCase,
#   - если тестируются API-едпоинты, то что общается вцелов со фронтендом и с остальными приложениями,
#     всегда лучше использовать APITestCase.

# При этом, для каждого приложения создается свой файл с тестами, поскольку это т.н. "инкапсулирование" -
# для каждого приложения - свои тесты, которые хранятся в каждом приложении по отдельности.

# Тестировать нужно ВСЕ поля модели как на позитивные сценарии, так и на негативные.

# VIDEO P.5, 2:22:30.
# Специально созданная небольшая модель SimpleBook с проверкой, является ли книга классическим произведением,
# для примера тестирования:
from library.models import SimpleBook


from django.urls import reverse
from rest_framework import status
import pytest

# VIDEO P.5, 2:38:00.
# Для демонстрации продвинутых техник с MOCK-ами ("мокинг", см. ниже), которые имитируют объекты через FactoryBoy.
from library.factories import SimpleBookFactory
# Продвинутые техники тестирования:
#   1. Детальнее про "мокинг" см. VIDEO P.6, 59:50.
#      Происходит от mocking - замена части кода или внешней зависимости дублером во время теста.
#      По-сути - подмена. Технически осуществляется mock-объектом.
#   2. FactoryBoy см. VIDEO P.6, 1:02:40. Суть в том, что писать много кода для тестирования большого
#      кол-ва полей в больших моделях утомительно. Для этого используются фабрики "factories".
#      Factory - шаблон для быстрого создания тестовых объектов.
#      Про установку ч/з "pip install factory-boy" см. в файл library/factories.py.
#      Для фабрик создается отдельный файл factories.py.
#      Теперь ВМЕСТО громоздкого APITestCase (смотри код для "class BookAPITestCase(APITestCase)") можно
#      написать более короткий код.
# ВЫВОД по FactoryBoy - экономит время и делает тесты гораздо чище.

# __ NB! __  Однако (VIDEO P.6, 1:11:00), если есть ForeignKey, нужно СТРОГО соблюдать ОЧЕРЕДНОСТЬ моделей.
# Т.е., если есть ForeignKey, то сначала нужно создавать "субличности", которые будут подключаться к
# основному объекту, а потом "основные личности". Т.е., если бы "author" был ForeignKey, то мы бы сначала
# создали автора, а потом подключили бы его к книге, чтобы протестировать ее. Т.е., нужно сначала описать
# себе логику по шагам, а потом все добавить в код factories.py.



# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# VIDEO P.5, 2:25:15.
# Первый тест для модели SimpleBook.
# Пометка, которая говорит pytest, что этот тест может работать с базой данных:
@pytest.mark.djang_db
def test_simple_book_model():
    """
    Тест для проверки создания объекта книги и работы кастомного метода is_classic().
    """
    # 1. Arrange (Подготовка): Создаем объект в памяти:
    book = SimpleBook.objects.create(
        title="Война и мир",
        author="Лев Толстой",
        publication_year=1869,
    )
    # -----  МОИ книги для тестирования -----------------------------------\
    # book = SimpleBook.objects.create(
    #     title="The Choice: Embrace the Possible",
    #     author="Eva Edith Eger",
    #     publication_year=2017,
    # )
    # book_modern = SimpleBook.objects.create(
    #         title="I Want and I Will",
    #         author="Mikhail Labkovsky",
    #         publication_year=2017,
    #     )
    # ----------------------------------------------------------------------/

    # -----  Код для FactoryBoy  --------------------------------------------------------------------|
    # VIDEO P.6, 1:09:00
    book = SimpleBookFactory(title='Title of a Book.')      # Можно переопределить поля, как здесь переименовано название книги.
    another_book = SimpleBookFactory()                      # Создаст книгу со случайными данными.

    # А если нужно много книг, тогда можно создать сразу много книг с пом. метода create_batch():
    five_books = SimpleBookFactory.create_batch(5)
    # ------------------------------------------------------------------------------------------------|

    # 2. Act (Действие) & Assert (Проверка)
    # Проверяем, что объект создался и его поля соответствуют ожидаемым:
    assert book.title == "The Choice: Embrace the Possible"
    # Проверяем работу метода __str__:
    assert str(book) == "The Choice: Embrace the Possible"
    # Проверяем кастомный метод is_classic() на позитивную работу, когда выводится True:
    assert book.is_classic() is True

    # 3. Создадим другую книгу для проверки обратного случая:
    book_modern = SimpleBook.objects.create(
        title="Гарри Поттер и философский камень",
        author="Джоан Роулинг",
        publication_year=1997,
    )
    # В этом примере она тоже будет классикой, поменяем на более новый год,
    # чтобы вывелось сообщение об ошибке при проверке, является ли книга классической:
    book_modern.publication_year = 2007
    # Проверяем кастомный метод is_classic() на негативную работу, когда должно вывестись False:
    assert book_modern.is_classic() is False




# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# VIDEO P.5, 2:38:00.
# Далее класс для тестирования API:
class BookAPITestCase(APITestCase):

    # -----  SETUP  (подготовка к тесту)  -------------------------------------------------
    @classmethod
    def setUpTestData(cls):
        """
        Этот метод вызывается один раз перед запуском всех тестов в классе.
        Идеально для создания объектов, которые не будут меняться.
        """
        cls.book1 = SimpleBook.objects.create(
            title="The Gift: 12 Lessons to Save Your Life",
            author="Eva Edith Eger",
            publication_year=2020,
        )
        cls.book2 = SimpleBook.objects.create(
            title="Yes To Life: In Spite of Everything",
            author="Viktor Frankl",
            publication_year=1946,
        )
        # Здесь будет производиться работа с ЗАРЕЗЕРВИРОВАННЫМИ именами, которые указывались в URL.
        # функция reverse() переводит на ендпоинт, который указан по имени в URL.
        # Получаем URL по его имени:
        cls.list_url = reverse('simple-book-list-create')
    # ---------------------------------------------------------------------------------------


    # -----  Собственно ТЕСТ  ---------------------------------------------------------------
    # VIDEO P.5, 2:42:30.
    def test_get_book_list(self):
        """
        Тест для GET-запроса (получение списка книг).
        """
        # Отправляем GET-запрос к нашему API:
        response = self.client.get(self.list_url)   # См. строку с cls.list_url, где лежит reverse('simple-book-list-create').
        # Проверяем, что ответ имеет статус-код 200 OK:
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # Проверяем, что в ответе 2 объекта, те созданные выыше cls.book1 и cls.book2:
        self.assertEqual(len(response.data.get('results')), 2)
        # VIDEO P.5, 2:44:10: Тесты работают ИНКАПСЮЛИРОВАНО от всей системы, что означает, что создается
        # временная БД, куда осуществляется setUp теста. Как только тест проходит, БД удаляется.

        # Проверяем, что данные одной из книг соответствуют ожиданиям,
        # т.е. РЕСПОНС.дата нашего ответа с названием книги response.data.get('results')[0]['title'] равен
        # заданному названию книги при ее создании self.book1.title.
        # По сути, в респонсе (ответе от БД) должно быть именно заданное название книги, а
        # не другая информация или какие-то кракозяблы:
        self.assertEqual(response.data.get('results')[0]['title'], self.book1.title)


    def test_create_book(self):
        """
        Тест для POST-запроса (создание новой книги).
        """
        # Данные для новой книги:
        data = {
            "title": "If This Is a Man",
            "author": "Primo Levi",
            "publication_year": 1947,
        }
        # Отправляем POST-запрос:
        response = self.client.post(self.list_url, data,format='json')
        # Проверяем, что ответ имеет статус-код 201 CREATED:
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # Проверяем, что количество книг в базе данных увеличилось на 1:
        self.assertEqual(SimpleBook.objects.count(), 3)
        # Проверяем, что созданная книга имеет правильный заголовок:
        new_book = SimpleBook.objects.get(id=response.data['id'])
        self.assertEqual(new_book.title, "If This Is a Man")

