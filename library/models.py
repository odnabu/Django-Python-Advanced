# Link on GitHub: https://github.com/viacheslav-bandylo/111124-projects/blob/main/library/models.pyfrom django.db import modelsfrom django.contrib.auth.models import Userfrom django.core.exceptions import ValidationErrorfrom django.core.validators import MaxValueValidator, MinValueValidatorfrom django.utils import timezonefrom django.utils.translation import gettext_lazy as _from library.managers import SoftDeleteManager# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# Таблица ОСНОВНОЙ информации об АВТОРЕ книги.class Author(models.Model):    """    Author of the book.    """    first_name = models.CharField(max_length=100, verbose_name="First name")    last_name = models.CharField(max_length=100, verbose_name="Last name")    date_of_birth = models.DateField(null=True, blank=True, verbose_name="Date of birth")    profile = models.URLField(null=True, blank=True, verbose_name="Profile URL")    is_deleted = models.BooleanField(        default=False, verbose_name="Is deleted",        help_text="When the Author is deleted it is set to False.",    )    rating = models.IntegerField(        validators=[MinValueValidator(1),                    MaxValueValidator(10)],        null=True, blank=True, verbose_name="Rating in library."    )    def __str__(self):        return f'{self.first_name} {self.last_name}'# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# Таблица с информацией об ИЗДАТЕЛЕ.class Publisher(models.Model):    """    Publisher of the book.    """    name = models.CharField(max_length=100, verbose_name="Name")    slug = models.SlugField(null=True, blank=True, default='publisher')    established_date = models.DateField()    def __str__(self):        return self.name# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# Таблица ЖАНРОВ.genre_choice = [    # In DB  | On site + Admin    ('Fiction', 'Fiction'),    ('Non Fiction', 'Non-Fiction'),    ('Sci-Fy', 'Science Fiction'),    ('Fantasy', 'Fantasy'),    ('Mystery', 'Mystery'),    ('Bibliography', 'Bibliography'),    ('Default', 'not_set'),]class Genre(models.Model):    """    Genre.    """    name = models.CharField(max_length=100, unique=True, blank=True,                            verbose_name="Genre",                            choices=genre_choice)    # Добавляем внутренний класс Meta:    class Meta:        # В атрибуте permissions объявляем кастомные права:        permissions = [            # Формат: ("имя_в_коде", "человекочитаемое_описание")            ("can_get_statistic", "Can get statistic"),        ]    def __str__(self):        return self.name# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# Таблица с информацией о КНИГЕ. Добавление / Обновление информации о книге в БД.class Book(models.Model):    """    Full information of the book.    Model consists relations to other models.    """    title = models.CharField(max_length=100, verbose_name="Book Title", blank=False)    publication_date = models.DateField(null=True, blank=False,                                        verbose_name="Publication Date")    description = models.TextField(null=True, blank=True, verbose_name="Summary")    amount_pages = models.PositiveIntegerField(null=True, blank=True,                                               verbose_name="Amount of Pages",                                               validators=[MaxValueValidator(10_000)])    created_at = models.DateTimeField(null=True, blank=True, verbose_name="Created at")    price = models.PositiveIntegerField(null=True, blank=True, verbose_name="Price")    is_banned = models.BooleanField(default=False, verbose_name="Is Banned")    is_deleted = models.BooleanField(default=False)      # Поле для мягкого удаления.    # ____  RELATIONS  ____    author = models.ForeignKey(Author, on_delete=models.SET_NULL,                               verbose_name="Author", null=True)    genres = models.ManyToManyField(Genre, related_name='books')    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE,                                  verbose_name="Publisher", null=True, blank=True)    category = models.ForeignKey('Category',    # 'Category' - в кавычках, потому что сама модель описана НИЖЕ.                                                    # Если бы она была описана выше, тогда можно было сослаться на                                                    # нее БЕЗ кавычек. Как, например, на модель Publisher.                                 on_delete=models.SET_NULL,                                 verbose_name="Category", null=True, blank=True,                                 related_name='books')    libraries = models.ManyToManyField("Library", verbose_name="Library",                                       related_name='books')    owner = models.ForeignKey(User, on_delete=models.SET_NULL,                              verbose_name="Owner", null=True,                              related_name='books')    # НЕ понятно для чего????????????    @property    def rating(self):        return self.reviews.all().aggregate(models.Avg('rating'))['rating__avg']    # __________  Мягкое удаление (soft deletion)  __________    objects = SoftDeleteManager()    all_objects = models.Manager()    # Переопределение стандартного метода удаления:    def delete(self, *args, **kwargs):        """        Redefining the standard method of deletion to the SOFT DELETE.        """        self.is_deleted = True      # Устанавливаем флаг.        self.save()                 # Сохраняем изменения в БД.    # Метод для восстановления записи:    def restore(self):        """        Restore the record with information about a book.        """        self.is_deleted = False        self.save()    # Что вернется в модели (классе):    def __str__(self):        return f'{self.title}'# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# См. Pr01-Adpractice_PrfS1-04_06.pdf, с. 8 (Задача 7):# Категории для книг: позволят пользователям более удобно фильтровать книги по# нужным им категориям.# Одна категория может быть у многих различных книг. Каждая книга может состоять# только в одной категории (для примера: Книга из категории “Для размышлений”,# жанр - “Психологический детектив”)class Category(models.Model):    """    Book's Category for the members of a library.    """    name = models.CharField(max_length=30, verbose_name="Category Title",                            unique=True)    def __str__(self):        return f'{self.name}'    class Meta:        verbose_name_plural = "Categories"# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# Таблица с информацией о Библиотеке, в которой хранится книга.class Library(models.Model):    """    Library, where the Book is.    """    title = models.CharField(max_length=100, verbose_name="Library Title",                             blank=False)    location = models.CharField(max_length=100, null=True, blank=True,                                verbose_name="Location of the Library")    website = models.URLField(null=True, blank=True, verbose_name="Website URL")    def __str__(self):        return f'{self.title}'    class Meta:        verbose_name_plural = "Libraries"# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# Таблица с информацией о членах библиотеки.gender_choices = [    ('M', 'Male'),    ('F', 'Femail')]role_choices = [    ('A', 'Administrator'),    ('R', 'Reader'),    ('E', 'Employee')]class Member(models.Model):    """    Member of a Library.    """    first_name = models.CharField(max_length=50, verbose_name="First name")    last_name = models.CharField(max_length=50, verbose_name="Last name")    emil = models.EmailField(null=False, blank=False, unique=True,                             verbose_name="Email")    gender = models.CharField(max_length=20, choices=gender_choices,                              verbose_name="Gender")    date_of_birth = models.DateField(verbose_name="Date of Birth")    age = models.PositiveIntegerField(editable=False, verbose_name="Age")       # __  NB!  __  editable    role = models.CharField(max_length=30, choices=role_choices,                            verbose_name="Role")    active = models.BooleanField(default=True, verbose_name="Is active")    # ____  RELATIONS  ____    libraries = models.ManyToManyField(Library, related_name='members',                                       verbose_name="Library")    # Переопределение метода сохранения с учетом проверки года рождения:    def save(self, *args, **kwargs):        ages = timezone.now().year - self.date_of_birth.year        if 6 <= ages < 120:            self.age = ages            super().save(*args, **kwargs)        else:            raise ValidationError(f"Age must be between 6 and 120 years."                                  f"Enter correct YEAR of birth.")    def __str__(self):        return f'{self.first_name} {self.last_name}'# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# Таблица с информацией об ПОСТАХ членам библиотеки.# См. Pr01-Adpractice_PrfS1-04_06.pdf, с. 12 (Задача 10):# Система постов: каждая библиотека может публиковать посты, они могут быть от# администратора, модератора. Более того, оглавление поста должно быть уникальным# в рамках создания такого поста, чтобы не было ничего повторяющегося.#   - Автор: ссылка на члена библиотеки, один автор может написать много постов#   - Промодерировано: по умолчанию ничего не промодерировано#   - Библиотека: связь к библиотеке. В каждой библиотеке может быть много своих постов#   - Дата создания: заполняется при создании мануально#   - Дата обновления: заполняется автоматическиclass Post(models.Model):    """    ?????????????????    """    created_at = models.DateTimeField(verbose_name="Created at")    title = models.CharField(max_length=255, unique_for_date='created_at',                             verbose_name="Titel of the Email")    text = models.TextField(null=False, blank=False, verbose_name="Text")    moderated = models.BooleanField(default=False, verbose_name="Moderated?")    updated_at = models.DateTimeField(auto_now=True)    # ____  RELATIONS  ____    author = models.ForeignKey(Member, on_delete=models.CASCADE,                               verbose_name="Author of the Email")    library = models.ForeignKey(Library, on_delete=models.CASCADE,                                verbose_name="Title of the Library in Email")# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# Таблица с информацией о взятой в библиотеке книге.class Borrow(models.Model):    """    Information about the book borrowed from the library.    """    book_take_date = models.DateField(auto_now_add=True, verbose_name="Book take Date")    book_return_date = models.DateField(verbose_name="Book return Date")    is_returned = models.BooleanField(default=False, verbose_name="Is returned?")    # ____  RELATIONS  ____    member = models.ForeignKey(Member, on_delete=models.CASCADE, verbose_name="Member")    book = models.ForeignKey(Book, on_delete=models.CASCADE, verbose_name="Borrowed Book")    library = models.ForeignKey(Library, on_delete=models.CASCADE, verbose_name="Library")    def __str__(self):        return (f'{self.member.first_name} {self.member.last_name} took'                f'"{self.book.title}" on {self.book_take_date}')    def check_to_date(self):        if timezone.now().date() > self.book_return_date and self.is_returned == False:            return True        else:            return False    # use python manage.py shell    # from library.models import Borrow    # a = Borrow.object.get(pk=<borrow id>)    # a.check_to_date()    # result: True or False# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# Таблица ОТЗЫВОВ на книги.class Review(models.Model):    review = models.TextField(verbose_name="Review of the book")    rating = models.FloatField(validators=[MinValueValidator(1), MaxValueValidator(5)],                               verbose_name="Rating of the Book")    # ____  RELATIONS  ____    books = models.ForeignKey(Book, on_delete=models.CASCADE, related_name='reviews',                              verbose_name="Reviewed Book")    reviewer = models.ForeignKey(Member, on_delete=models.CASCADE,                                 verbose_name="Reviewer")# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# Таблица ДЕТАЛЬНОЙ информации об авторе книги (см. МОДЕЛЬ в начале).class AuthorDetail(models.Model):    biography = models.TextField(verbose_name="Biography")    city = models.CharField(max_length=50, null=True, blank=True,                            verbose_name="City")    gender = models.CharField(max_length=20, choices=gender_choices, verbose_name="Gender")    # ____  RELATIONS  ____    author = models.ForeignKey(Author, on_delete=models.CASCADE,                                 verbose_name="Detailed information about Author")    def __str__(self):        return (f'{self.author.first_name} {self.author.last_name} from '                f'{self.city} born on {self.author.date_of_birth}')# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# Таблица МЕРОПРИЯТИЙ в библиотеке.class Event(models.Model):    name = models.CharField(max_length=255, verbose_name="Event name")    description = models.TextField(verbose_name="Event description")    timestamp = models.DateTimeField(verbose_name="Event Date and Time")    # ____  RELATIONS  ____    library = models.ForeignKey(Library, on_delete=models.CASCADE,                                verbose_name="Library")    book = models.ManyToManyField(Book, related_name='events', verbose_name="Books")    def __str__(self):        return f'{self.name} on {self.timestamp}'# Таблица УЧАСТНИКОВ мероприятий.class EventParticipant(models.Model):    register_date = models.DateField(auto_now_add=True, verbose_name="Date of Member's registration on Event")    # ____  RELATIONS  ____    event = models.ForeignKey(Event, on_delete=models.CASCADE, verbose_name="Event name")    member = models.ForeignKey(Member, on_delete=models.CASCADE, verbose_name="Member of the Event")    def __str__(self):        return (f'{self.event.name}. Member: {self.member.first_name} {self.member.last_name}'                f'registered on {self.register_date}')# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# VIDEO P.5, 2:22:30.#   VIDEO "Project 5: Консультация: финальный проект".#   url: https://player.vimeo.com/video/1106434843?h=9bf0582a7c# Специально созданная небольшая модель SimpleBook для примера тестирования:class SimpleBook(models.Model):    title = models.CharField(_('title'), max_length=255)    author = models.CharField(_('author'), max_length=255)    publication_year = models.PositiveIntegerField()    def __str__(self):        return f'{self.title}'    # Проверка, что все книги меньше 2000 года относятся к "классическим" произведениям:    def is_classic(self):        return self.publication_year < 2000# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%# Список стран:countries = [    ('DE', 'Germany'),    ('UK', 'United Kingdom'),    ('US', 'United States'),    ('PT', 'Portugal'),    ('FR', 'France'),    ('ES', 'Spain'),    ('IT', 'Italy'),]# Таблица с ОСНОВНОЙ информацией обо ВСЕХ пользователях (это для самого начала создания приложения library):class User(models.Model):    first_name = models.CharField(max_length=50, null=True, blank=True,                                  verbose_name="First/Given name")    last_name = models.CharField(max_length=70, null=True, blank=True,                                 verbose_name="Last/Family name")    age = models.PositiveIntegerField(validators=[MinValueValidator(18), MaxValueValidator(120)])    rating = models.FloatField(default=0.0)    country = models.CharField(choices=countries, default='DE', verbose_name="Country")# Таблица ДОПОЛНИТЕЛЬНОЙ информации (расширенной, т.е., не входящей во встроенную модель User).class UserInfo(models.Model):    married = models.BooleanField(verbose_name="Married?")    # ____  RELATIONS  ____    user = models.OneToOneField(User, on_delete=models.CASCADE, verbose_name="Additional User Info")# Les15-Django_16-Models-2.pdf, pp. 61, 63.# Таблица с информацией об АКТЕРАХ.class Actor(models.Model):    name = models.CharField(max_length=50)    def __str__(self):        return f'{self.name}'# Таблица с информацией о РЕЖИССЕРАХ.class Director(models.Model):    name = models.CharField(max_length=50)    experience = models.IntegerField(default=0)    def __str__(self):        return f'{self.name}'# Таблица с информацией о ФИЛЬМАХ.class Movie(models.Model):    title = models.CharField(max_length=50)    # ____  RELATIONS  ____    actors = models.ManyToManyField(Actor, related_name='movies')    director = models.ForeignKey(Director, null=True, blank=True,                                 on_delete=models.SET_NULL, related_name='movies')    def __str__(self):        if self.director:            return f'Title: "{self.title}" | Director: {self.director.name}'